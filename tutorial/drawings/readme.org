:PROPERTIES:
:header-args:lisp: :results file :exports both :package mlx-cl.tutorial.drawings :eval no-export :dir (expand-file-name ".")
:END:
#+title: MLX-CL.TUTORIAL.DRAWINGS
#+subtitle: Just draw something for fun
#+author: 凉凉
#+html_head: <!-- The documentation is generated on 11111000000/tao-theme-emacs (tao-yin) with org literal programming style.  -->
#+html_head: <!-- The Unifont is destributed on cdn.jsdelivr.net -->
#+html_head: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/unifont@5.2.5/index.min.css">
#+html_head: <style> body { font-size: 1.05em; background-color: #171717; color: #dadada } </style>
#+html_head: <style> pre, code { font-family: "Unifont", monospace; }</style>
#+html_head: <style> pre { background-color: #171717; } </style>
#+html_head: <style> a { display: inline-block; border: 1px solid; border-radius: 0px; border-color: #f6f6f6; text-decoration: none; color: #f6f6f6; padding: 1px; margin: 1px; } </style>
#+html_head: <style> a:hover { color: #0e0e0e; background-color: #c3c3c3 } </style>
#+html_head: <style> .title { padding-top: 100px; padding-bottom: 10px } </style>
* About
This is some trivial implementation and explanation of [[https://www.xordev.com/arsenal][XorDev's shader arts]]. [fn:a-sad-story]
To run the example codes, you should load the [[Package][package]] and switch to
=mlx-cl.tutorial.drawings= package.

* Waves
Consider a wave on x-axis: \(\mathrm{e}^{- \boldsymbol{k} \boldsymbol{x}}\), aka, \(\cos x\).

#+name: waves-x
#+header: :var size=200 output="./img/waves-x.png" scale=2
#+begin_src lisp
  (->o (fc size :scale scale :center t)
    (cos (x *))
    output)
#+end_src

#+caption: pattern of \(\cos x\) (~size = 200~, ~scale = 2~)
#+RESULTS: waves-x
[[file:./img/waves-x.png]]

considering the coordinates multiplied with the rotation matrix [[rotate2d][=rotate2d=]]:
\(\left(\begin{matrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{matrix}\right) \left(\begin{matrix} x \\ y \end{matrix}\right)\), which is equal to appling a rotation transformation
on the original coordinates:

#+name: waves-rotate-x
#+header: :var size=200 output="./img/waves-rotate-x.png" scale=2
#+begin_src lisp
  (->o (fc size :scale scale :center t)
    (cos (x (matmul (rotate2d (radians 30))
                    (expand-dims * -1))))
    output)
#+end_src

#+caption: Rotation of \(30^{\circ}\) of coordinates
#+RESULTS: waves-rotate-x
[[file:./img/waves-rotate-x.png]]

If adding two waves together, it would generate a pattern of interference fringes:

#+name: waves-2x
#+header: :var size=200 output="./img/waves-2x.png" scale=2
#+begin_src lisp
  (->o (fc size :scale scale :center t)
    (+ (cos (x (matmul (rotate2d (radians 30))
                       (expand-dims * -1))))
       (cos (x *)))
    output)
#+end_src

#+caption: Interference fringes of two waves
#+RESULTS: waves-2x
[[file:./img/waves-2x.png]]

if adding multiple waves all together:

#+name: waves
#+header: :var size=400 output="./img/waves.png" scale=0.8 repeat=40
#+begin_src lisp
  (->o (loop :repeat repeat
             :with r := (rotate2d (atanh (/ 6 8)))
             :for  p := (expand-dims (fc size :scale scale :center t) -1)
               :then (@ r p)
             :for x := (x p)
             :for o := (cos x) :then (add o (cos x))
             :finally (return (reshape o (list size size))))
    output)
#+end_src

#+attr_html: :width 200px
#+caption: 40 waves adding together, each rotating \(\tan^{-1} \frac{6}{8}\) (~size = 400~, ~scale=0.8~)
#+RESULTS: waves
[[file:./img/waves.png]]

#+html: <details><summary>Note: you may try different repeating times to see how the wave pattern generates. </summary>

+ ~repeat = 10~

  #+name: waves-repeat10
  #+call: waves(repeat=10,output="./img/waves-repeat10.png")

  #+attr_html: :width 200px
  #+caption: 10 waves adding together, each rotating \(\tan^{-1} \frac{6}{8}\) (~size = 400~, ~scale=0.8~)
  #+RESULTS: waves-repeat10
  [[file:./img/waves-repeat10.png]]
+ ~repeat = 20~

  #+name: waves-repeat20
  #+call: waves(repeat=20,output="./img/waves-repeat20.png")

  #+attr_html: :width 200px
  #+caption: 20 waves adding together, each rotating \(\tan^{-1} \frac{6}{8}\) (~size = 400~, ~scale=0.8~)
  #+RESULTS: waves-repeat20
  [[file:./img/waves-repeat20.png]]


#+html: </details>

* Appendix
** Package
:PROPERTIES:
:header-args:lisp: :results silent :exports both :package mlx-cl.tutorial.drawings :eval no-export :dir (expand-file-name ".")
:END:
This tutorial is based on =mlx-cl.tutorial.drawings= package,
which is generated by [[https://orgmode.org/manual/Extracting-Source-Code.html][org-tangle]].

#+html: <details><summary>The <code>drawings.lisp</code> overview</summary>
#+header: :tangle drawings.lisp :noweb yes no-export
#+begin_src lisp
  ;;;; drawings.lisp --- Just draw something for fun

  (uiop:define-package #:mlx-cl.tutorial.drawings
    (:use :mlx-cl))

  (in-package :mlx-cl.tutorial.drawings)

  ;;; Helper tools
  <<ensure-mlx-array-as-rgb-img>>
  <<arrows>>

  ;;;; drawings.lisp ends here
#+end_src
#+html: </details>

You could find the full script at [[file:drawings.lisp][drawings.lisp]].

*** =mlx-array=
+ as RGB =mlx-array= (H W C)

  #+name: ensure-mlx-array-as-rgb-img
  #+begin_src lisp
    (defun ensure-mlx-array-as-rgb-img (arr)
      "Ensure input ARR is (H W 3) `mlx-array' of dtype `:uint8'.
    Return the formatted `mlx-array'.

    Rule:
    + ARR (H W)   -> (H W 3)
    + ARR (H W 3) -> (H W 3)
    + ARR (H W 3) :uint8   -> ARR (H W 3) :uint8
    + ARR (H W 3) :float32 -> 255*ARR (H W 3) :uint8
    "
      (declare (type mlx-array arr))
      (->* (ecase (dim arr)
             (2 (reshape (repeat arr 3) `(,@(shape arr) 3)))
             (3 (ecase (len arr 2)
                  (1 (reshape (repeat arr 3) `(,@(shape arr) 3)))
                  (3 arr))))
        (ecase (dtype arr)
          (:uint8   arr)
          (:float32 (as-dtype (* * 255) :uint8)))))
  #+end_src
+ =fc= for [[https://registry.khronos.org/OpenGL-Refpages/gl4/html/gl_FragCoord.xhtml][=gl_FragCoord=]]

  #+begin_src lisp
    (defun fc (size &key (w size) (h size) (scale 1) (center nil)
                      (xmin (if center (/ w -2 scale) 0))
                      (xmax (if center (/ w  2 scale) scale))
                      (ymin (if center (/ h -2 scale) 0))
                      (ymax (if center (/ h  2 scale) scale)))
      "Return gl_FragCoord (H W (x y)=2). "
      (destructuring-bind (x y)
          (meshgrid (linspace xmin xmax w :dtype :float32)
                    (linspace ymax ymin h :dtype :float32))
        (stack x y :axis 2)))
  #+end_src
+ Getting subpart of =mlx-array=

  #+begin_src lisp
    (defmacro x (fc)
      "Get X part of FC (gl_FragCoord.x). "
      `(at ,fc :* :* 0))

    (defmacro y (fc)
      "Get Y part of FC (gl_FragCoord.y). "
      `(at ,fc :* :* 1))
  #+end_src
+ Rotation Matrix \(\left(\begin{matrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{matrix}\right)\)

  #+name: rotate2d
  #+begin_src lisp
    (defun rotate2d (theta)
      "Generate a 2-D vector rotation matrix. "
      (stack (stack (cos theta) (- (sin theta)))
             (stack (sin theta) (cos theta))))
  #+end_src
+ Matrix Multiplication

  #+begin_src lisp
    (defun ensure-h-w-2-1 (matrix-of-vec2)
      "Ensure MATRIX-OF-VEC2. "
      (ecase (dim matrix-of-vec2)
        (2
         (assert (len= matrix-of-vec2 2 2))
         (expand-dims matrix-of-vec2 -2))
        (3
         (assert (len= matrix-of-vec2 1 2))
         (assert (len= matrix-of-vec2 2 3))
         matrix-of-vec2)))

    (defun vec2@ (rotation matrix-of-vec2)
      "Multiply ROTATION matrix on MATRIX-OF-VEC2.
    Return matrix of rotated vec2.

    Parameters:
    + ROTATION: should be (M M) matrix
    + MATRIX-OF-VEC2: should be (H W 2) or (H W 2 1)
    "
      (assert (equal (shape rotation) '(2 2)))
      (matmul rotation (ensure-h-w-2-1 matrix-of-vec2)))
  #+end_src
*** Arrows
#+name: arrows
#+begin_src lisp
  (defmacro ->o (expr &body bodys-output)
    "Enhanced `->*' arrow to write image to OUTPUT.
  Return OUTPUT file path.

  Syntax:

      (->o EXPRS...
        OUTPUT)

  Parameters:
  + EXPRS: chained expressions, see `->*'
  + OUTPUT: image output path"
    `(->* ,expr
       ,@(butlast bodys-output)
       (ensure-mlx-array-as-rgb-img *)
       (save * :output ,@(last bodys-output))))
#+end_src

* Footnotes

[fn:a-sad-story] this can also serve as a test for MLX-CL library at some points...
In short, it works terribly great: the MLX library use a cache method for the
data exchange. So if you frequently calling massive data exchange without calling
=mlx:clear-cache=, it would easily eat up tons of memory. And thus i lost my previous
work of this tutorial... ha, ha, ... ha. (not so funny)

#+html: <br>

And another problem is that if frequently calling data exchange, which means coping
data twice in both MLX (FFI) and Lisp. That's tooooooo mean to my poor M2 (8GB) Air.
Currently (at the time I wrote this tutorial, maybe later in the future), you may need
to call =mlx:clear-cache= manually to free the cache. Seems to be that MLX is not so
actively freeing up it's memory?
