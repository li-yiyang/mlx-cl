#+title: MLX-CL
#+subtitle: Common Lisp bindings for MLX
#+author: 凉凉
#+html_head: <!-- The documentation is generated on 11111000000/tao-theme-emacs (tao-yin) with org literal programming style.  -->
#+html_head: <!-- The Unifont is destributed on cdn.jsdelivr.net -->
#+html_head: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/unifont@5.2.5/index.min.css">
#+html_head: <style> body { font-size: 1.05em; background-color: #171717; color: #dadada } </style>
#+html_head: <style> pre, code { font-family: "Unifont", monospace; }</style>
#+html_head: <style> pre { background-color: #171717; } </style>
#+html_head: <style> a { display: inline-block; border: 1px solid; border-radius: 0px; border-color: #f6f6f6; text-decoration: none; color: #f6f6f6; padding: 1px; margin: 1px; } </style>
#+html_head: <style> a:hover { color: #0e0e0e; background-color: #c3c3c3 } </style>
#+html_head: <style> .title { padding-top: 100px; padding-bottom: 10px } </style>
* About
MLX-CL is a Common Lisp binding for MLX, together with a set of trivial
data processing library.

*NOTE*: Github's org-mode renderer is buggy, please refer [[https://li-yiyang.github.io/mlx-cl][documentation]].

*TODO*:
+ more tests (the API tests are under =test/api.lisp=,
  tests of ops are under =test/ops.lisp=),
+ more documentations with examples (the ops are self-documented,
  use =(documentation #'mlx:+ 'function)= or =sly-documentation= for documentations)

* Usage
** Installation
You need:
a Common Lisp distribution (tested on SBCL 2.5.8, LispWorks Personal Edition 8.0.1),
[[https://www.quicklisp.org][Quicklisp]] (Common Lisp package manager),
and [[https://github.com/li-yiyang/mlx-cl][mlx-cl]] under where your quicklisp can find.

#+html: <details><summary>A possible installation process</summary>

Here's a possible installation process:

#+name: installation-demo
#+begin_src shell
  > mkdir -pv ~/common-lisp/
  > git clone --recursive https://github.com/li-yiyang/mlx-cl.git ~/common-lisp/mlx-cl
  ...
  > sbcl
  This is SBCL 2.5.8, an implementation of ANSI Common Lisp.
  More information about SBCL is available at <http://www.sbcl.org/>.

  SBCL is free software, provided as is, with absolutely no warranty.
  It is mostly in the public domain; some portions are provided under
  BSD-style licenses.  See the CREDITS and COPYING files in the
  distribution for more information.
  To load "trivial-indent":
    Load 1 ASDF system:
      trivial-indent
  ; Loading "trivial-indent"

  ,* (ql:quickload :mlx-cl)
  To load "mlx-cl":
    Load 1 ASDF system:
      mlx-cl
  ; Loading "mlx-cl"
  ..................................................
  ................................................
  (:mlx-cl)
  ,* (in-package :mlx-user)
  #<package "MLX-USER">
  ,* (+ 1 '(2 3 4))
  array([3, 4, 5], dtype=float32)
#+end_src

#+html: </details>

** Systems and Packages
:PROPERTIES:
:header-args:lisp: :eval no
:END:
The core functionalities are provided within system =mlx-cl=:

#+begin_src lisp
  (ql:quickload :mlx-cl)
#+end_src

would loads the following packages:
+ =mlx-cl=: the core binding package,
  if you are about to develop new packages, you should

  #+begin_src lisp
    (defpackage #:your-new-package-name
      (:use :mlx-cl))
  #+end_src

  note that the API of =mlx-cl= overwrites =cl='s functions,
  which makes =(:use :cl :mlx-cl)= difficult
+ =mlx-cl.fft=
+ =mlx-cl.linalg=
+ =mlx-cl.random=
+ =mlx-user= the following documentation are assumed to be written
  under =mlx-user= package

There are some subsystem(s) providing additional functionalities
above =mlx-cl=:
+ =mlx-cl/image=: see [[./image/][readme]] under =image= dir

** Basic Operations
:PROPERTIES:
:header-args:lisp: :results verbatim :exports both :package mlx-user
:END:

See tests in test/api.lisp for more examples.

*** Convert
1. Convert from Lisp to =mlx-array=
   To convert between =mlx-array= and Lisp array (data containers),
   use generic function =mlx-array=:

   + scalar to =mlx-array=

     #+name: scalar-to-mlx-array
     #+begin_src lisp
       (mlx-array 2)
     #+end_src

     #+RESULTS: scalar-to-mlx-array
     : array(2, dtype=int32)
   + list to =mlx-array=

     #+name: list-to-mlx-array
     #+begin_src lisp
       (mlx-array '((1 2) (3 4)))
     #+end_src

     #+RESULTS: list-to-mlx-array
     : array([[1, 2],
     :        [3, 4]], dtype=uint64)

   + array to =mlx-array=

     #+name: array-to-mlx-array
     #+begin_src lisp
       (mlx-array #3A(((1 2) (3 4))
                      ((5 6) (7 8))))
     #+end_src

     #+RESULTS: array-to-mlx-array
     : array([[[1, 2],
     :         [3, 4]],
     :        [[5, 6],
     :         [7, 8]]], dtype=uint64)

     *note*: use array, it's fast.

   You can implement methods to tell lisp how to convert your
   data into =mlx-array=.
2. Use =lisp<-= to convert =mlx-array= into Lisp value.

*** Alloc =mlx-array=
+ Generate by range:
  + =(arange [start] stop [step] &key step dtype)=

    #+begin_src lisp
      (arange 10)
    #+end_src

    #+RESULTS:
    : array([0, 1, 2, ..., 7, 8, 9], dtype=float32)
  + =(linspace start stop &optional num &key dtype)=
+ Generate array with constant values:
  + =(zeros SHAPE &key DTYPE)=
  + =(ones SHAPE &key DTYPE)=
  + =(full SHAPE &optional VALUE &key DTYPE)=

  #+begin_src lisp
    (full '(5 5) 2333)
  #+end_src

  #+RESULTS:
  : array([[2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333]], dtype=uint64)

+ Generate coordinate grids:
  + =(meshgrid arrays &key SPARES INDEXING)=

    #+begin_src lisp
      (meshgrid (arange -2 2)
                (arange -2 2))
    #+end_src

    #+RESULTS:
    : (array([[-2, -1, 0, 1],
    :        [-2, -1, 0, 1],
    :        [-2, -1, 0, 1],
    :        [-2, -1, 0, 1]], dtype=float32)
    :  array([[-2, -2, -2, -2],
    :        [-1, -1, -1, -1],
    :        [0, 0, 0, 0],
    :        [1, 1, 1, 1]], dtype=float32))

*** Indexing =mlx-array=
+ Use the highlevel API
  + =(at array &rest indexs)=
  + =(at* array &rest indexs)= (alias for =(lisp<- (at ...))=)

  the =indexs= could be
  + =(~ [start=0] stop [step=1] &key step)=
    + =(~ * * -1)= (equal to =(~ :step -1)=)
    + =(~ 0 * -1)= (equal to =(~ 0 -1 -1)=)
    + =(~ 5)= (equal to =(~ 0 5 1)=)
    + =(~ )= or just =~= (equal to =(~ 0 -1 -1)=)
  + integer
  + rational for first / last (negative) parts of axis
  + keywords for shortcuts, for example:
    + =:*= for all
    + =:first= for the first element on the corresponding axis
    + =:last= for the last element the corresponding axis
    + use =(documentation keyword 'mlx:slice)= to get the
      documentation of slice shortcuts documentations

  Examples:

  + take the all =(:*=) elements in first axis,
    second (=2=) element in second axis,
    =[0, 2)= elements in third axis:

    #+begin_src lisp
      (let ((arr (reshape (arange 0 9) '(3 3))))
        (at arr :* 2 (~ 0 2)))
    #+end_src

    #+RESULTS:
    : array([2, 5, 8], dtype=float32)

    this can also bewritten as:

    #+begin_src lisp
      (let ((arr (reshape (arange 0 9) '(3 3))))
        (at arr :all :second 1/2))
    #+end_src

    #+RESULTS:
    : array([2, 5, 8], dtype=float32)

    which means take all (=:all=) elements in first axis,
    second (=:second=) element in second axis,
    first half (=1/2=) in third axis.

*** Operations
MLX-CL overwrites a few of Common Lisp's methods (=cl:+=, =cl:-=, =cl:*=, =cl:/=, ...)
as generic functions. So if you don't worry about some speed lost, you can do

#+begin_src lisp
  (+ 1 (* 2 3) (/ 10 5))
#+end_src

#+RESULTS:
: 9 (4 bits, #x9, #o11, #b1001)

as if you are using =cl:+=, =cl:-=, =cl:*=, =cl:/= (other functions are the same).

For those functions that are not supported in normal common lisp functions:

#+begin_src lisp
  (+ 2 '(3 4 5))
#+end_src

#+RESULTS:
: array([5, 6, 7], dtype=float32)

they would be convert into =mlx-array= automatically. Use =lisp<-= to force
convert =mlx-array= as lisp value.

#+html: <details><summary>A example</summary>

the following example came from my Image Processing homework:

#+begin_src lisp :results none
  (defun gauss-kernel (sigma &optional m
                       &aux
                         (m-min (1+ (* 2 (ceiling (* 3 sigma)))))
                         (m-val (the (or null (integer 0)) (or m m-min))))
    "Return a Gauss kernel matrix.

  Definition:
     gauss(x, y) = exp(- (x^2 + y^2) / (2 * sigma^2)) / (2 * pi * sigma^2)
  "
    (declare (type (real 0) sigma)
             (type (or null integer) m))
    (when (lisp<- (< m-val m-min))
      (warn "Given m=~A is lower than m_min=~A. " m-val m-min))
    (let ((half (/ (1- m-val) 2)))
      (destructuring-bind (x y)
          (meshgrid (arange (- half) (1+ half))
                    (arange (- half) (1+ half)))
        (let ((ker (exp (- (/ (+ (square x) (square y))
                              (* 2 (square sigma)))))))
          (/ ker (sum ker))))))
#+end_src

which would produce:

#+begin_src lisp
  (gauss-kernel 0.3)
#+end_src

#+RESULTS:
: array([[1.47169e-05, 0.00380683, 1.47169e-05],
:        [0.00380683, 0.984714, 0.00380683],
:        [1.47169e-05, 0.00380683, 1.47169e-05]], dtype=float32)

#+html: </details>

* Contributing and Developing

*DEV Note*:
+ You could load system =mlx-cl/dev= to quickly load =mlx-cl= and =mlx-cl/test=,
  together with a set of indent rules to use with SLY/SLIME in Emacs.
+ There's some helpful Emacs scripts under =dev= which could help with
  developing MLX-CL
