:PROPERTIES:
:header-args:lisp: :results verbatim output :exports results :package mlx-user :eval no-export
:END:
#+title: MLX-CL
#+subtitle: Common Lisp bindings for MLX
#+author: 凉凉
#+html_head: <!-- The documentation is generated on 11111000000/tao-theme-emacs (tao-yin) with org literal programming style.  -->
#+html_head: <!-- The Unifont is destributed on cdn.jsdelivr.net -->
#+html_head: <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fontsource/unifont@5.2.5/index.min.css">
#+html_head: <style> body { font-size: 1.05em; background-color: #171717; color: #dadada } </style>
#+html_head: <style> pre, code { font-family: "Unifont", monospace; }</style>
#+html_head: <style> pre { background-color: #171717; } </style>
#+html_head: <style> a { display: inline-block; border: 1px solid; border-radius: 0px; border-color: #f6f6f6; text-decoration: none; color: #f6f6f6; padding: 1px; margin: 1px; } </style>
#+html_head: <style> a:hover { color: #0e0e0e; background-color: #c3c3c3 } </style>
#+html_head: <style> .title { padding-top: 100px; padding-bottom: 10px } </style>
* About
MLX-CL is a Common Lisp binding for MLX, together with a set of trivial
data processing library.

*NOTE*: Github's org-mode renderer is buggy, please refer [[https://li-yiyang.github.io/mlx-cl][documentation]].

*NOTE*: Although it may not be exactly true, but every exposed function,
class, variable in =mlx-cl= should came with feature-rich documentation.
If you've found documentation missing or not clear, it is DEFINITELY
an issue.

* Tutorials
If you're in hurry, skim through the [[Usage][Usage]] and read the documentation string
of each MLX-CL function (for example, =(documentation 'mlx:add 'function)=).

But you could also try some [[./tutorial/][Tutorial]] of MLX with some more specific topics.

* Usage
** Installation
You need:
a Common Lisp distribution (tested on SBCL 2.5.8, LispWorks Personal Edition 8.0.1),
[[https://www.quicklisp.org][Quicklisp]] (Common Lisp package manager),
and [[https://github.com/li-yiyang/mlx-cl][mlx-cl]] under where your quicklisp can find.

#+html: <details><summary>A possible installation process</summary>

Here's a possible installation process:

#+name: installation-demo
#+begin_src shell
  > mkdir -pv ~/common-lisp/
  > git clone --recursive https://github.com/li-yiyang/mlx-cl.git ~/common-lisp/mlx-cl
  ...
  > sbcl
  This is SBCL 2.5.8, an implementation of ANSI Common Lisp.
  More information about SBCL is available at <http://www.sbcl.org/>.

  SBCL is free software, provided as is, with absolutely no warranty.
  It is mostly in the public domain; some portions are provided under
  BSD-style licenses.  See the CREDITS and COPYING files in the
  distribution for more information.
  To load "trivial-indent":
    Load 1 ASDF system:
      trivial-indent
  ; Loading "trivial-indent"

  ,* (ql:quickload :mlx-cl)
  To load "mlx-cl":
    Load 1 ASDF system:
      mlx-cl
  ; Loading "mlx-cl"
  ..................................................
  ................................................
  (:mlx-cl)
  ,* (in-package :mlx-user)
  #<package "MLX-USER">
  ,* (+ 1 '(2 3 4))
  array([3, 4, 5], dtype=float32)
#+end_src

#+html: </details>

** Systems and Packages
:PROPERTIES:
:header-args:lisp: :eval no
:END:
The core functionalities are provided within system =mlx-cl=:

#+begin_src lisp
  (ql:quickload :mlx-cl)
#+end_src

would loads the following packages:
+ =mlx-cl=: the core binding package,
  if you are about to develop new packages, you should

  #+begin_src lisp
    (defpackage #:your-new-package-name
      (:use :mlx-cl))
  #+end_src

  note that the API of =mlx-cl= overwrites =cl='s functions,
  which makes =(:use :cl :mlx-cl)= difficult
+ =mlx-cl.fft= see [[FFT][FFT]] for examples
+ =mlx-cl.linalg=
+ =mlx-cl.random= see [[Random][Random]] for examples
+ =mlx-user= the following documentation are assumed to be written
  under =mlx-user= package.

  The =mlx-user= package is defined like:

  #+begin_src lisp
    (defpackage #:mlx-user
      (:use :mlx-cl)
      (:local-nicknames
       (:fft    :mlx-cl.fft)
       (:rnd    :mlx-cl.random)
       (:linalg :mlx-cl.linalg)))
  #+end_src

There are some subsystem(s) providing additional functionalities
above =mlx-cl=:
+ =mlx-cl/image=: see [[./image/][readme]] under =image= dir

** Basic Operations
See tests in =test/core/api.lisp= for more examples.

*** Convert
1. Convert from Lisp to =mlx-array=
   To convert between =mlx-array= and Lisp array (data containers),
   use generic function =mlx-array=:

   + scalar to =mlx-array=

     #+name: scalar-to-mlx-array
     #+begin_src lisp
       (mlx-array 2)
     #+end_src

     #+RESULTS: scalar-to-mlx-array
     : array(2, dtype=int32)
   + list to =mlx-array=

     #+name: list-to-mlx-array
     #+begin_src lisp
       (mlx-array '((1 2) (3 4)))
     #+end_src

     #+RESULTS: list-to-mlx-array
     : array([[1, 2],
     :        [3, 4]], dtype=uint64)

   + array to =mlx-array=

     #+name: array-to-mlx-array
     #+begin_src lisp
       (mlx-array #3A(((1 2) (3 4))
                      ((5 6) (7 8))))
     #+end_src

     #+RESULTS: array-to-mlx-array
     : array([[[1, 2],
     :         [3, 4]],
     :        [[5, 6],
     :         [7, 8]]], dtype=uint64)

     *note*: use array, it's fast.

   You can implement methods to tell lisp how to convert your
   data into =mlx-array=.
2. Use =lisp<-= to convert =mlx-array= into Lisp value.

   For example:

   #+begin_src lisp
     (lisp<- (mlx.rnd:randint 10 :shape #(5 5)))
   #+end_src

   #+RESULTS:
   : #2A((3 1 2 9 9) (8 9 0 1 1) (5 6 7 7 9) (3 4 5 2 7) (8 1 2 3 7))

3. Use =(mlx-array pathname)= to load =mlx-array= from =pathname=,
   how to load the =mlx-array= depends on the extension name
   of the pathname.

   For example, subsystem =mlx-cl/io/npy= provides NPY file I/O
   functionalities.

   #+begin_src lisp :results silent
     (ql:quickload :mlx-cl/io/npy)
   #+end_src

   If having a NPY file:

   #+begin_src python :results silent
     import numpy as np

     np.save("./res/tmp/example.npy", np.array([[1, 2, 3], [4, 5, 6]], dtype=np.float32))
   #+end_src

   #+begin_src lisp
     (mlx-array "./res/tmp/example.npy")
   #+end_src

   #+RESULTS:
   : array([[1, 2, 3],
   :        [4, 5, 6]], dtype=float32)

   You could write =mlx-array= as NPY using =save= function:

   #+begin_src lisp
     (->* (mlx-array #2A((1 2 3) (4 5 6)) :dtype :uint8)
       (save * :output "./res/tmp/example.npy"))
   #+end_src

   #+RESULTS:
   : ./res/tmp/example.npy

   #+begin_src python :results output
     import numpy as np

     print(np.load("./res/tmp/example.npy"))
   #+end_src

   #+RESULTS:
   : [[1 2 3]
   :  [4 5 6]]

   See [[I/O][I/O]] for more detailed description.

*** Alloc =mlx-array=
+ Generate by range:
  + =(arange [start] stop [step] &key step dtype)=

    #+begin_src lisp
      (arange 10)                             ; (arange STOP)
    #+end_src

    #+RESULTS:
    : array([0, 1, 2, ..., 7, 8, 9], dtype=float32)

    #+begin_src lisp
      (arange 5 10)                           ; (arange START STOP)
    #+end_src

    #+RESULTS:
    : array([5, 6, 7, 8, 9], dtype=float32)

    #+begin_src lisp
      (arange 2 10 2)                         ; (arange START STOP STEP)
    #+end_src

    #+RESULTS:
    : array([2, 4, 6, 8], dtype=float32)

  + =(linspace start stop &optional num &key dtype)=

    #+begin_src lisp
      (linspace 0 10) ; num=50 by default
    #+end_src

    #+RESULTS:
    : array([0, 0.204082, 0.408163, ..., 9.59184, 9.79592, 10], dtype=float32)

+ Generate array with constant values:
  + =(zeros SHAPE &key DTYPE)=
  + =(ones SHAPE &key DTYPE)=
  + =(full SHAPE &optional VALUE &key DTYPE)=

  #+begin_src lisp
    (full '(5 5) 2333)
  #+end_src

  #+RESULTS:
  : array([[2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333],
  :        [2333, 2333, 2333, 2333, 2333]], dtype=uint64)

+ Generate coordinate grids:
  + =(meshgrid arrays &key SPARES INDEXING)=

    #+begin_src lisp
      (meshgrid (arange -2 2)
                (arange -2 2))
    #+end_src

    #+RESULTS:
    : (array([[-2, -1, 0, 1],
    :        [-2, -1, 0, 1],
    :        [-2, -1, 0, 1],
    :        [-2, -1, 0, 1]], dtype=float32)
    :  array([[-2, -2, -2, -2],
    :        [-1, -1, -1, -1],
    :        [0, 0, 0, 0],
    :        [1, 1, 1, 1]], dtype=float32))

*** Indexing =mlx-array=
+ =at=: API like Python's =arr[...]=
  + =(at array &rest indexs)=
  + =(at* array &rest indexs)= (alias for =(lisp<- (at ...))=)

  the =indexs= could be
  + =(~ [start=0] stop [step=1] &key step)=
    + =(~ * * -1)= (equal to =(~ :step -1)=)
    + =(~ 0 * -1)= (equal to =(~ 0 -1 -1)=)
    + =(~ 5)= (equal to =(~ 0 5 1)=)
    + =(~ )= or just =~= (equal to =(~ 0 -1 -1)=)
  + integer
  + rational for first / last (negative) parts of axis
  + keywords for shortcuts, for example:
    + =:*= for all
    + =:first= for the first element on the corresponding axis
    + =:last= for the last element the corresponding axis
    + use =(documentation keyword 'mlx:slice)= to get the
      documentation of slice shortcuts documentations

  Examples:

  + take the all =(:*=) elements in first axis,
    second (=2=) element in second axis,
    =[0, 2)= elements in third axis:

    #+begin_src lisp
      (let ((arr (reshape (arange 0 27) '(3 3 3))))
        (at arr :* 1 (~ 0 2)))
    #+end_src

    #+RESULTS:
    : array([[3, 4],
    :        [12, 13],
    :        [21, 22]], dtype=float32)

    this can also bewritten as:

    #+begin_src lisp
      (let ((arr (reshape (arange 0 27) '(3 3 3))))
        (at arr :all :second 1/2))
    #+end_src

    #+RESULTS:
    : array([[3, 4],
    :        [12, 13],
    :        [21, 22]], dtype=float32)

    which means take all (=:all=) elements in first axis,
    second (=:second=) element in second axis,
    first half (=1/2=) in third axis.

    this is equal to calling MLX Python's API like:

    #+begin_src python :results output :exports both :eval no-export
      import mlx.core as mx
      print(mx.arange(0, 27).reshape((3, 3, 3))[:,1,0:2])
    #+end_src

    #+RESULTS:
    : array([[3, 4],
    :        [12, 13],
    :        [21, 22]], dtype=int32)
  + take all element in the first axis,
    the =0, 2, 3= th elements on the second axis:

    #+begin_src lisp
      (let ((arr (reshape (arange 0 20) '(2 10))))
        (at arr :* '(0 2 3)))
    #+end_src

    #+RESULTS:
    : array([[0, 2, 3],
    :        [10, 12, 13]], dtype=float32)

    this is equal to calling MLX Python's API like:

    #+begin_src python :results output :exports both :eval no-export
      import mlx.core as mx
      print(mx.arange(0, 20).reshape((2, 10))[:,[0, 2, 3]])
    #+end_src

    #+RESULTS:
    : array([[0, 2, 3],
    :        [10, 12, 13]], dtype=int32)

  *Dev Note*: You can use =defmlx-slice= to define alias of the
  slice shortcuts. For example, the shortcuts of =:all= can
  be defined as:

  #+begin_src lisp :results silent
    (defmlx-slice :all (shape)
      "Slice for all SHAPE. "
      (~ 0 shape 1))
  #+end_src

  The documentation of mlx slice can be show by:

  #+begin_src lisp
    (documentation :* 'at)
  #+end_src

  #+RESULTS:
  : Get all elements of axis in mlx-array.
  : Return (~ 0 SHAPE 1).

*** Operations
MLX-CL overwrites a few of Common Lisp's methods (=cl:+=, =cl:-=, =cl:*=, =cl:/=, ...)
as generic functions. So if you don't worry about some speed lost, you can do

#+begin_src lisp
  (+ 1 (* 2 3) (/ 10 5))
#+end_src

#+RESULTS:
: 9 (4 bits, #x9, #o11, #b1001)

as if you are using =cl:+=, =cl:-=, =cl:*=, =cl:/= (other functions are the same).

For those functions that are not supported in normal common lisp functions:

#+begin_src lisp
  (+ 2 '(3 4 5))
#+end_src

#+RESULTS:
: array([5, 6, 7], dtype=float32)

they would be convert into =mlx-array= automatically. Use =lisp<-= to force
convert =mlx-array= as lisp value.

#+html: <details><summary>A example</summary>

the following example came from my Image Processing homework:

#+begin_src lisp :results none
  (defun gauss-kernel (sigma &optional m
                       &aux
                         (m-min (1+ (* 2 (ceiling (* 3 sigma)))))
                         (m-val (the (or null (integer 0)) (or m m-min))))
    "Return a Gauss kernel matrix.

  Definition:
     gauss(x, y) = exp(- (x^2 + y^2) / (2 * sigma^2)) / (2 * pi * sigma^2)
  "
    (declare (type (real 0) sigma)
             (type (or null integer) m))
    (when (lisp<- (< m-val m-min))
      (warn "Given m=~A is lower than m_min=~A. " m-val m-min))
    (let ((half (/ (1- m-val) 2)))
      (destructuring-bind (x y)
          (meshgrid (arange (- half) (1+ half))
                    (arange (- half) (1+ half)))
        (let ((ker (exp (- (/ (+ (square x) (square y))
                              (* 2 (square sigma)))))))
          (/ ker (sum ker))))))
#+end_src

which would produce:

#+begin_src lisp
  (gauss-kernel 0.3)
#+end_src

#+RESULTS:
: array([[1.47169e-05, 0.00380683, 1.47169e-05],
:        [0.00380683, 0.984714, 0.00380683],
:        [1.47169e-05, 0.00380683, 1.47169e-05]], dtype=float32)

#+html: </details>

** Random
The package =mlx-cl.random= is a collection of PRNG processes in MLX.

#+begin_src lisp :results verbatim
  (loop :repeat 3 :collect (list (rnd:uniform) (rnd:uniform :key 0)))
#+end_src

#+RESULTS:
: ((array(0.0390083, dtype=float32) array(0.418457, dtype=float32))
:  (array(0.42697, dtype=float32) array(0.418457, dtype=float32))
:  (array(0.976773, dtype=float32) array(0.418457, dtype=float32)))

the API in =mlx-cl.random= use =:key= as the random seed locally,
or you could use =mlx.rnd:seed= to set a seed globally.

#+begin_src lisp
  (rnd:seed 2333)
  (rnd:uniform 10 :shape '(4 4))
#+end_src

#+RESULTS:
: array([[1.27809, 2.80545, 6.38505, 6.99261],
:        [3.23088, 3.66074, 1.126, 0.481315],
:        [9.99442, 4.19935, 2.59734, 9.24549],
:        [1.32391, 1.80017, 5.53488, 4.57218]], dtype=float32)

** FFT
The package =mlx-cl.fft= is a collection of FFT processes binding in MLX.

#+begin_src lisp
  (fft:fft #(1 2 3 4))
#+end_src

#+RESULTS:
: array([10+0j, -2+2j, -2+0j, -2-2j], dtype=complex64)

and inverse FFT:

#+begin_src lisp
  (fft:ifft (fft:fft #(1 2 3 4)))
#+end_src

#+RESULTS:
: array([1+-0j, 2+-0j, 3+0j, 4+-0j], dtype=complex64)

Note: in order to acclerate, =mlx.fft:1dfft=, =mlx.fft:2dfft= would be faster.

** I/O
:PROPERTIES:
:header-args:lisp: :results verbatim output :exports results :package mlx-user :eval no-export
:END:

The high-level API of reading and writing =mlx-array= is:
+ =(mlx-array pathname &key ...)=
+ =(save mlx-array &key output ...)=

Behind the scene, it calls:

+ =(load-from source format &key)=
+ =(save-to object output format &key)=

Use these functions if failed to guess correct =format= keyword from
the pathname.

If you want to define your own format reading and writing functionalities,
you can use the: =(defmlx-extension (format . extensions) &rest options)=.

#+begin_src lisp
  (write-string (documentation 'defmlx-extension 'function))
#+end_src

#+RESULTS:
#+begin_example
Define the implementation of mlx FORMAT.
Add EXTENSIONS to `*mlx-supported-extensions*' as FORMAT.

Syntax:

    (defmlx-extension (format . extensions)
      ((:load-path path :lambda-list ... :element-type ...)
        load-doc
        load-code)
      ((:load stream :lambda-list ... :element-type ...)
        load-doc
        load-code)
      ((:save-path arr path :lambda-list ... :element-type ...)
        save-doc
        save-code)
      ((:save arr stream :lambda-list ... :element-type ...)
        save-doc
        save-code))

#+end_example

Currently implemented io submodules are:
+ [[./io/npy/][=mlx-cl/io/npy=]]: read and write NPY file via [[https://github.com/marcoheisig/numpy-file-format][marcoheisig/numpy-file-format]]
+ [[./io/png/][=mlx-cl/io/png=]]: read and write PNG file via [[https://github.com/lisp-mirror/pngload][pngload]] and [[https://www.quicklisp.org/beta/UNOFFICIAL/docs/zpng/doc/index.html][zpng]]
+ [[./io/jpeg/][=mlx-cl/io/jpeg=]]: read and write JPEG file via [[https://github.com/sharplispers/cl-jpeg][sharplispers/cl-jpeg]]
+ [[./io/tiff/][=mlx-cl/io/tiff=]]: read and write TIFF file via [[https://github.com/slyrus/retrospectiff][slyrus/retrospectiff]]

* Contributing and Developing

*DEV Note*:
+ You could load system =mlx-cl/dev= to quickly load =mlx-cl= and =mlx-cl/test=,
  together with a set of indent rules to use with SLY/SLIME in Emacs.
+ There's some helpful Emacs scripts under =dev= which could help with
  developing MLX-CL

  read more in [[./dev/elisp/][MLX-CL/DEV/ELISP]]
